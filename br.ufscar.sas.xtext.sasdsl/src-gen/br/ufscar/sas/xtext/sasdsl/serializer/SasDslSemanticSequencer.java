/*
 * generated by Xtext 2.21.0
 */
package br.ufscar.sas.xtext.sasdsl.serializer;

import br.ufscar.sas.xtext.sasdsl.sasDsl.ArchitectureDefinition;
import br.ufscar.sas.xtext.sasdsl.sasDsl.BasicType;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Can;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Cannot;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCDecl;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLComponent;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLComponentInterface;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLLayer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLModule;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DCLSubSystem;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAlternative;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLDomainRule;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLEffector;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLKnowledge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaged;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManagerController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaging;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMeasuredOutput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLPlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLReferenceInput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleKnowledge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMO;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRulePlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLSensor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.EntityType;
import br.ufscar.sas.xtext.sasdsl.sasDsl.InterfaceType;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Must;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Only;
import br.ufscar.sas.xtext.sasdsl.sasDsl.Only2;
import br.ufscar.sas.xtext.sasdsl.sasDsl.SasDslPackage;
import br.ufscar.sas.xtext.sasdsl.services.SasDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SasDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SasDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SasDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SasDslPackage.ARCHITECTURE_DEFINITION:
				sequence_ArchitectureDefinition(context, (ArchitectureDefinition) semanticObject); 
				return; 
			case SasDslPackage.BASIC_TYPE:
				sequence_BasicType(context, (BasicType) semanticObject); 
				return; 
			case SasDslPackage.CAN:
				sequence_Can(context, (Can) semanticObject); 
				return; 
			case SasDslPackage.CANNOT:
				sequence_Cannot(context, (Cannot) semanticObject); 
				return; 
			case SasDslPackage.DC_DECL:
				sequence_DCDecl(context, (DCDecl) semanticObject); 
				return; 
			case SasDslPackage.DCL_COMPONENT:
				sequence_DCLComponent(context, (DCLComponent) semanticObject); 
				return; 
			case SasDslPackage.DCL_COMPONENT_INTERFACE:
				sequence_DCLComponentInterface(context, (DCLComponentInterface) semanticObject); 
				return; 
			case SasDslPackage.DCL_LAYER:
				sequence_DCLLayer(context, (DCLLayer) semanticObject); 
				return; 
			case SasDslPackage.DCL_MODULE:
				sequence_DCLModule(context, (DCLModule) semanticObject); 
				return; 
			case SasDslPackage.DCL_SUB_SYSTEM:
				sequence_DCLSubSystem(context, (DCLSubSystem) semanticObject); 
				return; 
			case SasDslPackage.DSL_ALTERNATIVE:
				sequence_DSLAlternative(context, (DSLAlternative) semanticObject); 
				return; 
			case SasDslPackage.DSL_ANALYZER:
				sequence_DSLAnalyzer(context, (DSLAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DSL_CONTROLLER:
				sequence_DSLController(context, (DSLController) semanticObject); 
				return; 
			case SasDslPackage.DSL_DOMAIN_RULE:
				sequence_DSLDomainRule(context, (DSLDomainRule) semanticObject); 
				return; 
			case SasDslPackage.DSL_EFFECTOR:
				sequence_DSLEffector(context, (DSLEffector) semanticObject); 
				return; 
			case SasDslPackage.DSL_EXECUTOR:
				sequence_DSLExecutor(context, (DSLExecutor) semanticObject); 
				return; 
			case SasDslPackage.DSL_KNOWLEDGE:
				sequence_DSLKnowledge(context, (DSLKnowledge) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGED:
				sequence_DSLManaged(context, (DSLManaged) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGER_CONTROLLER:
				sequence_DSLManagerController(context, (DSLManagerController) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGING:
				sequence_DSLManaging(context, (DSLManaging) semanticObject); 
				return; 
			case SasDslPackage.DSL_MEASURED_OUTPUT:
				sequence_DSLMeasuredOutput(context, (DSLMeasuredOutput) semanticObject); 
				return; 
			case SasDslPackage.DSL_MONITOR:
				sequence_DSLMonitor(context, (DSLMonitor) semanticObject); 
				return; 
			case SasDslPackage.DSL_PLANNER:
				sequence_DSLPlanner(context, (DSLPlanner) semanticObject); 
				return; 
			case SasDslPackage.DSL_REFERENCE_INPUT:
				sequence_DSLReferenceInput(context, (DSLReferenceInput) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_ANALYZER:
				sequence_DSLRuleAnalyzer(context, (DSLRuleAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_CONTROLLER:
				sequence_DSLRuleController(context, (DSLRuleController) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_EXECUTOR:
				sequence_DSLRuleExecutor(context, (DSLRuleExecutor) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_KNOWLEDGE:
				sequence_DSLRuleKnowledge(context, (DSLRuleKnowledge) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MCONTROLLER:
				sequence_DSLRuleMController(context, (DSLRuleMController) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MO:
				sequence_DSLRuleMO(context, (DSLRuleMO) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MONITOR:
				sequence_DSLRuleMonitor(context, (DSLRuleMonitor) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_PLANNER:
				sequence_DSLRulePlanner(context, (DSLRulePlanner) semanticObject); 
				return; 
			case SasDslPackage.DSL_SENSOR:
				sequence_DSLSensor(context, (DSLSensor) semanticObject); 
				return; 
			case SasDslPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case SasDslPackage.INTERFACE_TYPE:
				sequence_InterfaceType(context, (InterfaceType) semanticObject); 
				return; 
			case SasDslPackage.MUST:
				sequence_Must(context, (Must) semanticObject); 
				return; 
			case SasDslPackage.ONLY:
				sequence_Only(context, (Only) semanticObject); 
				return; 
			case SasDslPackage.ONLY2:
				sequence_Only2(context, (Only2) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArchitectureDefinition returns ArchitectureDefinition
	 *
	 * Constraint:
	 *     (name=ID managing+=DSLManaging+ managed+=DSLManaged+ rules+=DSLRules* dCDecl+=DCDecl*)
	 */
	protected void sequence_ArchitectureDefinition(ISerializationContext context, ArchitectureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementType returns BasicType
	 *     BasicType returns BasicType
	 *
	 * Constraint:
	 *     (typeName='access' | typeName='declare' | typeName='handle' | typeName='create' | typeName='depend')
	 */
	protected void sequence_BasicType(ISerializationContext context, BasicType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Can returns Can
	 *
	 * Constraint:
	 *     can='can-'
	 */
	protected void sequence_Can(ISerializationContext context, Can semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.CAN__CAN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.CAN__CAN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCanAccess().getCanCanKeyword_0(), semanticObject.getCan());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Cannot returns Cannot
	 *
	 * Constraint:
	 *     cannot='cannot-'
	 */
	protected void sequence_Cannot(ISerializationContext context, Cannot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.CANNOT__CANNOT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.CANNOT__CANNOT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCannotAccess().getCannotCannotKeyword_0(), semanticObject.getCannot());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DCDecl returns DCDecl
	 *
	 * Constraint:
	 *     (
	 *         (only=Only t=[DCLStructureElement|FQN] can=Can elementType=ElementType type=[DCLStructureElement|FQN]) | 
	 *         (t=[DCLStructureElement|FQN] cannot=Cannot elementType=ElementType type=[DCLStructureElement|FQN]) | 
	 *         (t=[DCLStructureElement|FQN] can=Can elementType=ElementType type=[DCLStructureElement|FQN]) | 
	 *         (t=[DCLStructureElement|FQN] can=Can elementType=ElementType only2=Only2 type=[DCLStructureElement|FQN]) | 
	 *         (t=[DCLStructureElement|FQN] must=Must entityType=EntityType type=[DCLStructureElement|FQN])
	 *     )
	 */
	protected void sequence_DCDecl(ISerializationContext context, DCDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLStructureElement returns DCLComponentInterface
	 *     DCLComponentInterface returns DCLComponentInterface
	 *
	 * Constraint:
	 *     (name=ID component=[DCLStructureElement|ID] interfaceType=InterfaceType)
	 */
	protected void sequence_DCLComponentInterface(ISerializationContext context, DCLComponentInterface semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DCL_STRUCTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DCL_STRUCTURE_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DCL_COMPONENT_INTERFACE__COMPONENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DCL_COMPONENT_INTERFACE__COMPONENT));
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DCL_COMPONENT_INTERFACE__INTERFACE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DCL_COMPONENT_INTERFACE__INTERFACE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDCLComponentInterfaceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDCLComponentInterfaceAccess().getComponentDCLStructureElementIDTerminalRuleCall_3_0_1(), semanticObject.eGet(SasDslPackage.Literals.DCL_COMPONENT_INTERFACE__COMPONENT, false));
		feeder.accept(grammarAccess.getDCLComponentInterfaceAccess().getInterfaceTypeInterfaceTypeParserRuleCall_4_2_0(), semanticObject.getInterfaceType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DCLStructureElement returns DCLComponent
	 *     DCLComponent returns DCLComponent
	 *
	 * Constraint:
	 *     (name=ID (layer=[DCLStructureElement|ID] | subSystem=[DCLStructureElement|ID])?)
	 */
	protected void sequence_DCLComponent(ISerializationContext context, DCLComponent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLStructureElement returns DCLLayer
	 *     DCLLayer returns DCLLayer
	 *
	 * Constraint:
	 *     (name=ID level=INT (layer=[DCLStructureElement|ID] | subSystem=[DCLStructureElement|ID] | component=[DCLStructureElement|ID])?)
	 */
	protected void sequence_DCLLayer(ISerializationContext context, DCLLayer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DCLStructureElement returns DCLModule
	 *     DCLModule returns DCLModule
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DCLModule(ISerializationContext context, DCLModule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DCL_STRUCTURE_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DCL_STRUCTURE_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDCLModuleAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DCLStructureElement returns DCLSubSystem
	 *     DCLSubSystem returns DCLSubSystem
	 *
	 * Constraint:
	 *     (name=ID subSystem=[DCLStructureElement|ID]?)
	 */
	protected void sequence_DCLSubSystem(ISerializationContext context, DCLSubSystem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAlternative returns DSLAlternative
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLAlternative(ISerializationContext context, DSLAlternative semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ALTERNATIVE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ALTERNATIVE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLAlternativeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLAnalyzer returns DSLAnalyzer
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLAnalyzer(ISerializationContext context, DSLAnalyzer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLAnalyzerAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLController returns DSLController
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         domain=DSLDomainRule? 
	 *         monitor+=DSLMonitor* 
	 *         analyzer+=DSLAnalyzer* 
	 *         planner+=DSLPlanner* 
	 *         executor+=DSLExecutor* 
	 *         knowledge+=DSLKnowledge*
	 *     )
	 */
	protected void sequence_DSLController(ISerializationContext context, DSLController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLDomainRule returns DSLDomainRule
	 *
	 * Constraint:
	 *     (value=ID | value='withDomainRules')
	 */
	protected void sequence_DSLDomainRule(ISerializationContext context, DSLDomainRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLEffector returns DSLEffector
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLEffector(ISerializationContext context, DSLEffector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLEffectorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLExecutor returns DSLExecutor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLExecutor(ISerializationContext context, DSLExecutor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLExecutorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLKnowledge returns DSLKnowledge
	 *
	 * Constraint:
	 *     (name=ID referenceInput+=DSLReferenceInput* shalt+=DSLAlternative*)
	 */
	protected void sequence_DSLKnowledge(ISerializationContext context, DSLKnowledge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManaged returns DSLManaged
	 *
	 * Constraint:
	 *     (name=ID sensor+=DSLSensor* effector+=DSLEffector* measuredOutput+=DSLMeasuredOutput* structureElements+=DCLStructureElement*)
	 */
	protected void sequence_DSLManaged(ISerializationContext context, DSLManaged semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManagerController returns DSLManagerController
	 *
	 * Constraint:
	 *     (name=ID controller+=DSLController+)
	 */
	protected void sequence_DSLManagerController(ISerializationContext context, DSLManagerController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManaging returns DSLManaging
	 *
	 * Constraint:
	 *     (name=ID managerController+=DSLManagerController* controller+=DSLController*)
	 */
	protected void sequence_DSLManaging(ISerializationContext context, DSLManaging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLMeasuredOutput returns DSLMeasuredOutput
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLMeasuredOutput(ISerializationContext context, DSLMeasuredOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUTPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUTPUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMeasuredOutputAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLMonitor returns DSLMonitor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLMonitor(ISerializationContext context, DSLMonitor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMonitorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLPlanner returns DSLPlanner
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLPlanner(ISerializationContext context, DSLPlanner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLPlannerAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLReferenceInput returns DSLReferenceInput
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLReferenceInput(ISerializationContext context, DSLReferenceInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLReferenceInputAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleAnalyzer
	 *     DSLRuleAnalyzer returns DSLRuleAnalyzer
	 *
	 * Constraint:
	 *     (
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') monitor=[DSLMonitor|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') analyzer2=[DSLAnalyzer|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') executor=[DSLExecutor|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') rreference=[DSLReferenceInput|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') shalt=[DSLAlternative|ID])
	 *     )
	 */
	protected void sequence_DSLRuleAnalyzer(ISerializationContext context, DSLRuleAnalyzer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleController
	 *     DSLRuleController returns DSLRuleController
	 *
	 * Constraint:
	 *     (controller1=[DSLController|ID] (access='must-use' | access='must-not-use') controller2=[DSLController|ID])
	 */
	protected void sequence_DSLRuleController(ISerializationContext context, DSLRuleController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleExecutor
	 *     DSLRuleExecutor returns DSLRuleExecutor
	 *
	 * Constraint:
	 *     (
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') monitor=[DSLMonitor|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') executor2=[DSLExecutor|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') effector=[DSLEffector|ID])
	 *     )
	 */
	protected void sequence_DSLRuleExecutor(ISerializationContext context, DSLRuleExecutor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleKnowledge
	 *     DSLRuleKnowledge returns DSLRuleKnowledge
	 *
	 * Constraint:
	 *     (
	 *         (knowledge=[DSLKnowledge|ID] (access='must-use' | access='must-not-use') monitor=[DSLMonitor|ID]) | 
	 *         (knowledge=[DSLKnowledge|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (knowledge=[DSLKnowledge|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (knowledge=[DSLKnowledge|ID] (access='must-use' | access='must-not-use') executor=[DSLExecutor|ID])
	 *     )
	 */
	protected void sequence_DSLRuleKnowledge(ISerializationContext context, DSLRuleKnowledge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMController
	 *     DSLRuleMController returns DSLRuleMController
	 *
	 * Constraint:
	 *     (mcontroller1=[DSLManagerController|ID] (access='must-use' | access='must-not-use') mcontroller2=[DSLManagerController|ID])
	 */
	protected void sequence_DSLRuleMController(ISerializationContext context, DSLRuleMController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMO
	 *     DSLRuleMO returns DSLRuleMO
	 *
	 * Constraint:
	 *     (sensor=[DSLSensor|ID] (access='must-use' | access='must-not-use') measured=[DSLMeasuredOutput|ID])
	 */
	protected void sequence_DSLRuleMO(ISerializationContext context, DSLRuleMO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMonitor
	 *     DSLRuleMonitor returns DSLRuleMonitor
	 *
	 * Constraint:
	 *     (
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') monitor2=[DSLMonitor|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') executor=[DSLExecutor|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') sensor=[DSLSensor|ID])
	 *     )
	 */
	protected void sequence_DSLRuleMonitor(ISerializationContext context, DSLRuleMonitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRulePlanner
	 *     DSLRulePlanner returns DSLRulePlanner
	 *
	 * Constraint:
	 *     (
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') monitor=[DSLMonitor|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') planner2=[DSLPlanner|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') executor=[DSLExecutor|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') shalt=[DSLAlternative|ID])
	 *     )
	 */
	protected void sequence_DSLRulePlanner(ISerializationContext context, DSLRulePlanner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLSensor returns DSLSensor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLSensor(ISerializationContext context, DSLSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_SENSOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_SENSOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementType returns EntityType
	 *     EntityType returns EntityType
	 *
	 * Constraint:
	 *     (entity='extend' | entity='implement' | entity='derive' | entity='throw' | entity='useannotation')
	 */
	protected void sequence_EntityType(ISerializationContext context, EntityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InterfaceType returns InterfaceType
	 *
	 * Constraint:
	 *     (interfaceTypeName='provided' | interfaceTypeName='required')
	 */
	protected void sequence_InterfaceType(ISerializationContext context, InterfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Must returns Must
	 *
	 * Constraint:
	 *     must='must-'
	 */
	protected void sequence_Must(ISerializationContext context, Must semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.MUST__MUST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.MUST__MUST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMustAccess().getMustMustKeyword_0(), semanticObject.getMust());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Only2 returns Only2
	 *
	 * Constraint:
	 *     only2='-only'
	 */
	protected void sequence_Only2(ISerializationContext context, Only2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.ONLY2__ONLY2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.ONLY2__ONLY2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnly2Access().getOnly2OnlyKeyword_0(), semanticObject.getOnly2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Only returns Only
	 *
	 * Constraint:
	 *     only='only'
	 */
	protected void sequence_Only(ISerializationContext context, Only semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.ONLY__ONLY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.ONLY__ONLY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnlyAccess().getOnlyOnlyKeyword_0(), semanticObject.getOnly());
		feeder.finish();
	}
	
	
}
