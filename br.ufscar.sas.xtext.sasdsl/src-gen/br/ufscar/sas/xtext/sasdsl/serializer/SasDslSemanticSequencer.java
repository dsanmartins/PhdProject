/*
 * generated by Xtext 2.16.0
 */
package br.ufscar.sas.xtext.sasdsl.serializer;

import br.ufscar.sas.xtext.sasdsl.sasDsl.ArchitectureDefinition;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLEffector;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLKnowledge;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaged;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManagerController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLManaging;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMeasuredOutput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLPlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLReferenceInput;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleAnalyzer;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleExecutor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMController;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMO;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMonitor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRulePlanner;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLSelfHealingAlt;
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLSensor;
import br.ufscar.sas.xtext.sasdsl.sasDsl.SasDslPackage;
import br.ufscar.sas.xtext.sasdsl.services.SasDslGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SasDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SasDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SasDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SasDslPackage.ARCHITECTURE_DEFINITION:
				sequence_ArchitectureDefinition(context, (ArchitectureDefinition) semanticObject); 
				return; 
			case SasDslPackage.DSL_ANALYZER:
				sequence_DSLAnalyzer(context, (DSLAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DSL_CONTROLLER:
				sequence_DSLController(context, (DSLController) semanticObject); 
				return; 
			case SasDslPackage.DSL_EFFECTOR:
				sequence_DSLEffector(context, (DSLEffector) semanticObject); 
				return; 
			case SasDslPackage.DSL_EXECUTOR:
				sequence_DSLExecutor(context, (DSLExecutor) semanticObject); 
				return; 
			case SasDslPackage.DSL_KNOWLEDGE:
				sequence_DSLKnowledge(context, (DSLKnowledge) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGED:
				sequence_DSLManaged(context, (DSLManaged) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGER_CONTROLLER:
				sequence_DSLManagerController(context, (DSLManagerController) semanticObject); 
				return; 
			case SasDslPackage.DSL_MANAGING:
				sequence_DSLManaging(context, (DSLManaging) semanticObject); 
				return; 
			case SasDslPackage.DSL_MEASURED_OUTPUT:
				sequence_DSLMeasuredOutput(context, (DSLMeasuredOutput) semanticObject); 
				return; 
			case SasDslPackage.DSL_MONITOR:
				sequence_DSLMonitor(context, (DSLMonitor) semanticObject); 
				return; 
			case SasDslPackage.DSL_PLANNER:
				sequence_DSLPlanner(context, (DSLPlanner) semanticObject); 
				return; 
			case SasDslPackage.DSL_REFERENCE_INPUT:
				sequence_DSLReferenceInput(context, (DSLReferenceInput) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_ANALYZER:
				sequence_DSLRuleAnalyzer(context, (DSLRuleAnalyzer) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_CONTROLLER:
				sequence_DSLRuleController(context, (DSLRuleController) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_EXECUTOR:
				sequence_DSLRuleExecutor(context, (DSLRuleExecutor) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MCONTROLLER:
				sequence_DSLRuleMController(context, (DSLRuleMController) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MO:
				sequence_DSLRuleMO(context, (DSLRuleMO) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_MONITOR:
				sequence_DSLRuleMonitor(context, (DSLRuleMonitor) semanticObject); 
				return; 
			case SasDslPackage.DSL_RULE_PLANNER:
				sequence_DSLRulePlanner(context, (DSLRulePlanner) semanticObject); 
				return; 
			case SasDslPackage.DSL_SELF_HEALING_ALT:
				sequence_DSLSelfHealingAlt(context, (DSLSelfHealingAlt) semanticObject); 
				return; 
			case SasDslPackage.DSL_SENSOR:
				sequence_DSLSensor(context, (DSLSensor) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArchitectureDefinition returns ArchitectureDefinition
	 *
	 * Constraint:
	 *     (name=ID managing+=DSLManaging+ managed+=DSLManaged+ rules+=DSLRules*)
	 */
	protected void sequence_ArchitectureDefinition(ISerializationContext context, ArchitectureDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLAnalyzer returns DSLAnalyzer
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLAnalyzer(ISerializationContext context, DSLAnalyzer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_ANALYZER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_ANALYZER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLAnalyzerAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLController returns DSLController
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         monitor+=DSLMonitor+ 
	 *         analyzer+=DSLAnalyzer+ 
	 *         planner+=DSLPlanner+ 
	 *         executor+=DSLExecutor+ 
	 *         knowledge+=DSLKnowledge+
	 *     )
	 */
	protected void sequence_DSLController(ISerializationContext context, DSLController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLEffector returns DSLEffector
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLEffector(ISerializationContext context, DSLEffector semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EFFECTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLEffectorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLExecutor returns DSLExecutor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLExecutor(ISerializationContext context, DSLExecutor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_EXECUTOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLExecutorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLKnowledge returns DSLKnowledge
	 *
	 * Constraint:
	 *     (name=ID referenceInput+=DSLReferenceInput+ shalt+=DSLSelfHealingAlt*)
	 */
	protected void sequence_DSLKnowledge(ISerializationContext context, DSLKnowledge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManaged returns DSLManaged
	 *
	 * Constraint:
	 *     (name=ID sensor+=DSLSensor+ effector+=DSLEffector+ measuredOutput+=DSLMeasuredOutput+)
	 */
	protected void sequence_DSLManaged(ISerializationContext context, DSLManaged semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManagerController returns DSLManagerController
	 *
	 * Constraint:
	 *     (name=ID dslTypeMC=DSLTypeMC controller+=DSLController+)
	 */
	protected void sequence_DSLManagerController(ISerializationContext context, DSLManagerController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLManaging returns DSLManaging
	 *
	 * Constraint:
	 *     (name=ID managerController+=DSLManagerController* controller+=DSLController*)
	 */
	protected void sequence_DSLManaging(ISerializationContext context, DSLManaging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLMeasuredOutput returns DSLMeasuredOutput
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLMeasuredOutput(ISerializationContext context, DSLMeasuredOutput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUTPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MEASURED_OUTPUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMeasuredOutputAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLMonitor returns DSLMonitor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLMonitor(ISerializationContext context, DSLMonitor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_MONITOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_MONITOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLMonitorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLPlanner returns DSLPlanner
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLPlanner(ISerializationContext context, DSLPlanner semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_PLANNER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_PLANNER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLPlannerAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLReferenceInput returns DSLReferenceInput
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLReferenceInput(ISerializationContext context, DSLReferenceInput semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_REFERENCE_INPUT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLReferenceInputAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleAnalyzer
	 *     DSLRuleAnalyzer returns DSLRuleAnalyzer
	 *
	 * Constraint:
	 *     (
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') monitor=[DSLMonitor|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') rreference=[DSLReferenceInput|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') analyzer2=[DSLAnalyzer|ID]) | 
	 *         (analyzer=[DSLAnalyzer|ID] (access='must-use' | access='must-not-use') shalt=[DSLSelfHealingAlt|ID])
	 *     )
	 */
	protected void sequence_DSLRuleAnalyzer(ISerializationContext context, DSLRuleAnalyzer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleController
	 *     DSLRuleController returns DSLRuleController
	 *
	 * Constraint:
	 *     (controller1=[DSLController|ID] (access='must-use' | access='must-not-use') controller2=[DSLController|ID])
	 */
	protected void sequence_DSLRuleController(ISerializationContext context, DSLRuleController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleExecutor
	 *     DSLRuleExecutor returns DSLRuleExecutor
	 *
	 * Constraint:
	 *     (
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') effector=[DSLEffector|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') planner=[DSLPlanner|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (executor=[DSLExecutor|ID] (access='must-use' | access='must-not-use') executor2=[DSLExecutor|ID])
	 *     )
	 */
	protected void sequence_DSLRuleExecutor(ISerializationContext context, DSLRuleExecutor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMController
	 *     DSLRuleMController returns DSLRuleMController
	 *
	 * Constraint:
	 *     (mcontroller1=[DSLManagerController|ID] (access='must-use' | access='must-not-use') mcontroller2=[DSLManagerController|ID])
	 */
	protected void sequence_DSLRuleMController(ISerializationContext context, DSLRuleMController semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMO
	 *     DSLRuleMO returns DSLRuleMO
	 *
	 * Constraint:
	 *     (sensor=[DSLSensor|ID] (access='must-use' | access='must-not-use') measured=[DSLMeasuredOutput|ID])
	 */
	protected void sequence_DSLRuleMO(ISerializationContext context, DSLRuleMO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRuleMonitor
	 *     DSLRuleMonitor returns DSLRuleMonitor
	 *
	 * Constraint:
	 *     (
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') sensor=[DSLSensor|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (monitor=[DSLMonitor|ID] (access='must-use' | access='must-not-use') monitor2=[DSLMonitor|ID])
	 *     )
	 */
	protected void sequence_DSLRuleMonitor(ISerializationContext context, DSLRuleMonitor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLRules returns DSLRulePlanner
	 *     DSLRulePlanner returns DSLRulePlanner
	 *
	 * Constraint:
	 *     (
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') knowledge=[DSLKnowledge|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') analyzer=[DSLAnalyzer|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') executor=[DSLExecutor|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') planner2=[DSLPlanner|ID]) | 
	 *         (planner=[DSLPlanner|ID] (access='must-use' | access='must-not-use') shalt=[DSLSelfHealingAlt|ID])
	 *     )
	 */
	protected void sequence_DSLRulePlanner(ISerializationContext context, DSLRulePlanner semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DSLSelfHealingAlt returns DSLSelfHealingAlt
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLSelfHealingAlt(ISerializationContext context, DSLSelfHealingAlt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_SELF_HEALING_ALT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_SELF_HEALING_ALT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLSelfHealingAltAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DSLSensor returns DSLSensor
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_DSLSensor(ISerializationContext context, DSLSensor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SasDslPackage.Literals.DSL_SENSOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SasDslPackage.Literals.DSL_SENSOR__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDSLSensorAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
