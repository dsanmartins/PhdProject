/*
 * generated by Xtext 2.10.0
 */
package br.ufscar.sas.xtext.sasdsl.generator

import br.ufscar.sas.xtext.sasdsl.sasDsl.ArchitectureDefinition
import java.util.HashMap
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleController
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMonitor
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleAnalyzer
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRulePlanner
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleExecutor
import br.ufscar.sas.xtext.sasdsl.sasDsl.DSLRuleMO

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SasDslGenerator extends AbstractGenerator {

	var structureElementPath = new HashMap<String,String>();
	var outAggregatedPath = new HashMap<String,String>();
	var aggregatedPath = new HashMap<String,String>();
	
	var depth = newArrayList(5);

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		
		for (e : resource.allContents.toIterable.filter(ArchitectureDefinition))
		{
			this.createPath(e)
			fsa.generateFile("PlannedArchitecture.xmi", e.compile)
			fsa.generateFile("Constraints.ocl", e.compile2)
		}
	}
	
	def createPath(ArchitectureDefinition architecture){
		
		depth.clear();
		depth.add(0,0)
		depth.add(1,0)
		depth.add(2,0)
		depth.add(3,0)
		depth.add(4,0)
		
		
		var managing = architecture.managing
		for (var i=0; i< managing.size; i++){
			
			var level0 = depth.get(0)
			var man = managing.get(i)
			structureElementPath.put(man.name, "//@model.1/@structureElement."+ level0)
			
			
			var mcontroller = man.managerController
			for (var j=0; j<mcontroller.size ; j++){
					
				var level1=depth.get(1)
				var mcon = mcontroller.get(j)
				structureElementPath.put(mcon.name,"//@model.1/@structureElement."+ level0 +"/" + "@structureElement."+ level1)
				
				var controller = mcon.controller
				for (var k=0; k< controller.size ; k++){
					
					var level2 = depth.get(2)
					var con = controller.get(k)
					structureElementPath.put(con.name,"//@model.1/@structureElement."+ level0 +
														"/" + "@structureElement."+ level1 +
														 "/" + "@structureElement."+ level2)
	
					var monitor = con.monitor
					for (var l=0; l< monitor.size; l++){
						
						var level3 = depth.get(3)
						var mon = monitor.get(l)
						structureElementPath.put(mon.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3)										
						level3++
						depth.set(3,level3)
					}
					
					var analyzer = con.analyzer
					for (var l=0; l< analyzer.size; l++){
						
						var level3 = depth.get(3)
						var ana = analyzer.get(l)
						structureElementPath.put(ana.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3)										
						level3++
						depth.set(3,level3)
					}
					
					var planner = con.planner
					for (var l=0; l< planner.size; l++){
						
						var level3 = depth.get(3)
						var pla = planner.get(l)
						structureElementPath.put(pla.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3)										
						level3++
						depth.set(3,level3)
					}
					
					var executor = con.executor
					for (var l=0; l< executor.size; l++){
						
						var level3 = depth.get(3)
						var exe = executor.get(l)
						structureElementPath.put(exe.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3)										
						level3++
						depth.set(3,level3)
					}
					
					var knowledge = con.knowledge
					for (var l=0; l< knowledge.size; l++){
						
						var level3 = depth.get(3)
						var kno = knowledge.get(l)
						structureElementPath.put(kno.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3)										
						
						var ri = kno.referenceInput
						for (var m = 0; m < ri.size; m++)
						{
							var level4 = depth.get(4);
							var r = ri.get(m)
							structureElementPath.put(r.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 + 
															"/" + "@structureElement."+ level3 +
															"/" + "@structureElement."+ level4)					
							level4++
							depth.set(4,level4)
						}
						
						level3++
						depth.set(3,level3)
					}

					level2++
					depth.set(2,level2)
					
				}
				
				level1++
				depth.set(1,level1)
				
			}
			
			level0++
			depth.set(0,level0)
			
			
			var controller= man.controller
			for (var k=0; k< controller.size ; k++){
					
					var level1 = depth.get(1)
					var con = controller.get(k)
					structureElementPath.put(con.name,"//@model.1/@structureElement."+ level0 +
														 "/" + "@structureElement."+ level1)
	
					var monitor = con.monitor
					for (var l=0; l< monitor.size; l++){
						
						var level2 = depth.get(2)
						var mon = monitor.get(l)
						structureElementPath.put(mon.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2)										
						level2++
						depth.set(2,level2)
					}
					
					var analyzer = con.analyzer
					for (var l=0; l< analyzer.size; l++){
						
						var level2 = depth.get(2)
						var ana = analyzer.get(l)
						structureElementPath.put(ana.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2)										
						level2++
						depth.set(2,level2)
					}
					
					var planner = con.planner
					for (var l=0; l< planner.size; l++){
						
						var level2 = depth.get(2)
						var pla = planner.get(l)
						structureElementPath.put(pla.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2)										
						level2++
						depth.set(2,level2)
					}
					
					var executor = con.executor
					for (var l=0; l< executor.size; l++){
						
						var level2 = depth.get(2)
						var exe = executor.get(l)
						structureElementPath.put(exe.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2)										
						level2++
						depth.set(2,level2)
					}
					
					var knowledge = con.knowledge
					for (var l=0; l< knowledge.size; l++){
						
						var level2 = depth.get(2)
						var kno = knowledge.get(l)
						structureElementPath.put(kno.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2)										
						
						var ri = kno.referenceInput
						for (var m = 0; m < ri.size; m++)
						{
							var level3 = depth.get(3);
							var r = ri.get(m)
							structureElementPath.put(r.name,"//@model.1/@structureElement."+ level0 + 
															"/" + "@structureElement."+ level1 + 
															"/" + "@structureElement."+ level2 +
															"/" + "@structureElement."+ level3)					
							level3++
							depth.set(3,level3)
						}
						
						level2++
						depth.set(2,level2)
					}

					level1++
					depth.set(1,level1)
					
				}
				
			level0++
			depth.set(0,level0)
		}
		
		var managed = architecture.managed
		for (var i=0; i< managed.size; i++){
			
			var level0 = depth.get(0)
			var man = managed.get(i)
			structureElementPath.put(man.name, "//@model.1/@structureElement."+ level0)
			
			var sensor = man.sensor
			for (var k = 0; k < sensor.size ; k++)
			{
				var level1 = depth.get(1)
				var sen = sensor.get(k)
				structureElementPath.put(sen.name, "//@model.1/@structureElement."+ level0 + 
															"/"+ "@structureElement."+ level1 )
			
				level1++
				depth.set(1,level1)			
			}
			
			var effector = man.effector
			for (var k = 0; k < effector.size ; k++)
			{
				var level1 = depth.get(1)
				var efe = effector.get(k)
				structureElementPath.put(efe.name, "//@model.1/@structureElement."+ level0 + 
															"/"+ "@structureElement."+ level1 )
			
				level1++
				depth.set(1,level1)			
			}
			
			var mea = man.measuredOutput
			for (var k = 0; k < mea.size ; k++)
			{
				var level1 = depth.get(1)
				var me = mea.get(k)
				structureElementPath.put(me.name, "//@model.1/@structureElement."+ level0 + 
															"/"+ "@structureElement."+ level1 )
			
				level1++
				depth.set(1,level1)			
			}
			
			level0++
			depth.set(0,level0)
			
		}
		
		var rule = architecture.rules
		var rController = 0
		var outController = ""
		var rMonitor =0
		var outMonitor = ""
		var rAnalyzer=0
		var outAnalyzer = ""
		var rPlanner=0
		var outPlanner = ""
		var rExecutor=0
		var outExecutor = ""
		var rMO=0
		var outMO = ""
		
		for (var i=0; i< rule.size ; i++){
			
			var r = rule.get(i)
			if (r.access.equals("can-access"))
			{
				if (r instanceof DSLRuleController){
					
					var path = outAggregatedPath.get(r.controller.name)
					if (path !== null)
					{
							outController = outController + "/@aggregated."+rController
					}
				
					
									
				}
				else {
					if (r instanceof DSLRuleMonitor){
						
						
					
						
					}
					else {
						if (r instanceof DSLRuleAnalyzer) {
							
							
							
							
						}
						else {
							
							if (r instanceof DSLRulePlanner) {
								
									
								
								
							}
							else
							{
								if (r instanceof DSLRuleExecutor ) {
									
									
									
								}
								else {
									
									if (r instanceof DSLRuleMO ) {
									
										
										
									}
									
								}
							}
						}
					}
				}
			}	
		}
	}
	
	def compile(ArchitectureDefinition architectureDefinition){
				
		'''
		<?xml version="1.0" encoding="UTF-8"?>
		<xmi:XMI xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:action="http://www.eclipse.org/MoDisco/kdm/action" xmlns:code="http://www.eclipse.org/MoDisco/kdm/code" xmlns:kdm="http://www.eclipse.org/MoDisco/kdm/kdm" xmlns:source="http://www.eclipse.org/MoDisco/kdm/source" xmlns:structure="http://www.eclipse.org/MoDisco/kdm/structure">
			<kdm:Segment name="Planned Architecture">
			<model xsi:type="code:CodeModel" name="Elements Instances">
				<codeElement xsi:type="code:Module" name="Module Instance">
					<codeElement xsi:type="code:CodeElement" name="codeElement Instance">
			       		<codeRelation xsi:type="code:Extends"/>
			       		<codeRelation xsi:type="code:Implements"/>
			        	<codeRelation xsi:type="code:HasValue"/>
			      	</codeElement>
					<codeElement xsi:type="action:ActionElement" name="actionElement Instance">
			        	<actionRelation xsi:type="action:Calls"/>
			        	<actionRelation xsi:type="action:UsesType"/>
			        	<actionRelation xsi:type="action:Creates"/>
			    	</codeElement>
				</codeElement>
			</model>
			<extension xsi:type="kdm:ExtensionFamily" name="Adaptive System Domain">
			     <stereotype name="Monitor" type="structure:Component"/>
			     <stereotype name="Analyzer" type="structure:Component"/>
			     <stereotype name="Planner" type="structure:Component"/>
			     <stereotype name="Executor" type="structure:Component"/>
			     <stereotype name="Knowledge" type="structure:Component"/>
			     <stereotype name="Reference Input" type="structure:Component"/>
			     <stereotype name="Measured Output" type="structure:Component"/>
			     <stereotype name="Control Loop Manager" type="structure:Component"/>
			     <stereotype name="Control Loop" type="structure:Component"/>
			     <stereotype name="Sensor" type="structure:Component"/>
			     <stereotype name="Effector" type="structure:Component"/>
			     <stereotype name="Managing Subsystem" type="structure:Subsystem"/>
			     <stereotype name="Managed Subsystem" type="structure:Subsystem"/>
			</extension>
			<model xsi:type="structure:StructureModel" name="Architecture Abstractions">
				«FOR arch : architectureDefinition.managing»
				<structureElement xsi:type="structure:Subsystem" name="«arch.name»" stereotype="/0/@extension.0/@stereotype.11">
					«FOR mcontroller: arch.managerController»
						<structureElement xsi:type="structure:Component" name="«mcontroller.name»" stereotype="/0/@extension.0/@stereotype.7">
							«FOR controller: mcontroller.controller»
							<structureElement xsi:type="structure:Component" name="«controller.name»" stereotype="/0/@extension.0/@stereotype.8">
								«FOR monitor: controller.monitor»
								<structureElement xsi:type="structure:Component" name="«monitor.name»" stereotype="/0/@extension.0/@stereotype.0">
													
								</structureElement>
								«ENDFOR»
								«FOR analyzer: controller.analyzer»
								<structureElement xsi:type="structure:Component" name="«analyzer.name»" stereotype="/0/@extension.0/@stereotype.1">
																			
								</structureElement>
								«ENDFOR»
								«FOR planner: controller.planner»
								<structureElement xsi:type="structure:Component" name="«planner.name»" stereotype="/0/@extension.0/@stereotype.2">
																									
								</structureElement>
								«ENDFOR»
								«FOR executor: controller.executor»
								<structureElement xsi:type="structure:Component" name="«executor.name»" stereotype="/0/@extension.0/@stereotype.3">
																														
								</structureElement>
								«ENDFOR»
								«FOR knowledge: controller.knowledge»
								<structureElement xsi:type="structure:Component" name="«knowledge.name»" stereotype="/0/@extension.0/@stereotype.4">
									«FOR referenceInput: knowledge.referenceInput»
									<structureElement xsi:type="structure:Component" name="«referenceInput.name»" stereotype="/0/@extension.0/@stereotype.5"/>
									«ENDFOR»																											
								</structureElement>
								«ENDFOR»
							</structureElement>
						«ENDFOR»
						</structureElement>
					</structureElement>
					«ENDFOR»
					«FOR controller: arch.controller»
					<structureElement xsi:type="structure:Component" name="«controller.name»" stereotype="/0/@extension.0/@stereotype.8">
						«FOR monitor: controller.monitor»
						<structureElement xsi:type="structure:Component" name="«monitor.name»" stereotype="/0/@extension.0/@stereotype.0">
																		
						</structureElement>
						«ENDFOR»
						«FOR analyzer: controller.analyzer»
						<structureElement xsi:type="structure:Component" name="«analyzer.name»" stereotype="/0/@extension.0/@stereotype.1">
																								
						</structureElement>
						«ENDFOR»
						«FOR planner: controller.planner»
						<structureElement xsi:type="structure:Component" name="«planner.name»" stereotype="/0/@extension.0/@stereotype.2">
																														
						</structureElement>
						«ENDFOR»
						«FOR executor: controller.executor»
						<structureElement xsi:type="structure:Component" name="«executor.name»" stereotype="/0/@extension.0/@stereotype.3">
																																			
						</structureElement>
						«ENDFOR»
						«FOR knowledge: controller.knowledge»
						<structureElement xsi:type="structure:Component" name="«knowledge.name»" stereotype="/0/@extension.0/@stereotype.4">
							«FOR referenceInput: knowledge.referenceInput»
							<structureElement xsi:type="structure:Component" name="«referenceInput.name»" stereotype="/0/@extension.0/@stereotype.5"/>
							«ENDFOR»																											
						</structureElement>
						«ENDFOR»
					</structureElement>
					«ENDFOR»
				</structureElement>
				«ENDFOR»
			
				«FOR arch : architectureDefinition.managed»
				<structureElement xsi:type="structure:Subsystem" name="«arch.name»" stereotype="/0/@extension.0/@stereotype.12">
					«FOR sensor : arch.sensor»
					<structureElement xsi:type="structure:Component" name="«sensor.name»" stereotype="/0/@extension.0/@stereotype.9">
									
					</structureElement>			
					«ENDFOR»
					«FOR effector : arch.effector»
					<structureElement xsi:type="structure:Component" name="«effector.name»" stereotype="/0/@extension.0/@stereotype.10">
													
					</structureElement>			
					«ENDFOR»
					«FOR measuredOutput : arch.measuredOutput»
					<structureElement xsi:type="structure:Component" name="«measuredOutput.name»" stereotype="/0/@extension.0/@stereotype.6">
																	
					</structureElement>			
					«ENDFOR»
				</structureElement>			
				«ENDFOR»
			</model>
			</kdm:Segment>	
		</xmi:XMI>
		'''
		
	}
	
	def compile2(ArchitectureDefinition architectureDefinition){
		
		'''
		
		
		'''
		
		
		
	}
}
